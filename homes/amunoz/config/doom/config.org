#+TITLE: My literate doom emacs config

* Basics

#+begin_src emacs-lisp :tangle yes
(setq user-full-name "Alán Muñoz"
      user-mail-address "Alan.Munoz@ed.ac.uk")

#+end_src

Browse from anywhere
#+begin_src emacs-lisp :tangle no
(add-to-list '+lookup-provider-url-alist '("Kagi" "https://kagi.com/search?q=%s"))
#+end_src


** Essentials
Set fish as terminal by default, if not available use "$SHELL".
#+begin_src emacs-lisp :tangle yes
(setq fish-location (executable-find "fish"))
(setq vterm-shell (if (file-exists-p fish-location) fish-location (getenv "SHELL")))
(setq shell-file-name vterm-shell)
(setq explicit-shell-file-name "/bin/bash")

;; For fish to work
(add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
(ansi-color-for-comint-mode-on)
#+end_src

#+RESULTS:
: t
Remove LD_LIBRARY_PATH because it affects JAX
#+begin_src emacs-lisp :tangle yes
(setenv "LD_LIBRARY_PATH" nil)
#+end_src
Make ',' the local header key. Speeds up keybindings.
#+begin_src emacs-lisp :tangle yes
(setq doom-localleader-key ",")
#+end_src

#+RESULTS:
: ,

#+begin_src elisp :tangle yes
(setq ns-alternate-modifier 'meta)
(setq ns-right-alternate-modifier 'none)
#+end_src

** vterm in guix
#+begin_src elisp :tangle no
(when (and (string-equal system-type "gnu/linux") (fboundp 'guix-emacs-autoload-packages))
  (add-to-list 'load-path "~/.guix-profile/share/emacs/site-lisp")
  (guix-emacs-autoload-packages))
#+end_src

#+RESULTS:

** Snippets that are Nice to have
#+begin_src emacs-lisp :tangle yes
  (defun arrayify (start end quote)
    "Turn strings on newlines into a QUOTEd, comma-separated one-liner."
    (interactive "r\nMQuote: ")
    (let ((insertion
           (mapconcat
            (lambda (x) (format "%s%s%s" quote x quote))
            (split-string (buffer-substring start end)) ", ")))
      (delete-region start end)
      (insert insertion)))
#+end_src
** Theme
Use modus-vivendi as theme
#+begin_src emacs-lisp :tangle yes
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'modus-vivendi)
(setq modus-themes-org-blocks 'gray-background)
#+end_src

#+RESULTS:
: gray-background

** Font
Doom exposes five (optional) variables for controlling fonts in Doom. Here
are the three important ones:

+ `doom-font'
;; + `doom-variable-pitch-font'
+ `doom-big-font' -- used for `doom-big-font-mode'
use this for
presentations or streaming.

They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
font string. You generally only need these two:
(setq doom-font (font-spec :family "Deja Vu Sans Mono" :size 16))
;; (setq doom-font (font-spec :family "Iosevka" :size 18)
;; Set the font  based on which computer is in use.

#+begin_src emacs-lisp :tangle yes
(defun which-linux-distribution ()
  "from lsb_release"
  (when (eq system-type 'gnu/linux)
    (shell-command-to-string "lsb_release -sd")))

#+end_src


If Iosevka is installed use it
#+begin_src emacs-lisp :tangle yes
(setq font-to-try "Iosevka")
(if  (member font-to-try (font-family-list))
    (setq doom-font (font-spec :family font-to-try :size 18))
    (setq doom-font (font-spec :family "monospace" :size 18)))

#+end_src

Variable font pitch if using Arran
#+begin_src emacs-lisp :tangle yes

(setq variable-pitch-font-to-try "Overpass")
(when (member variable-pitch-font-to-try (font-family-list))
            doom-variable-pitch-font (font-spec :family variable-pitch-font-to-try :size 18))

#+end_src

** Quality of Life
auto-revert mode (Refreshing files after disk changes)
#+begin_src emacs-lisp :tangle yes
(global-auto-revert-mode t)
(repeat-mode t)
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp :tangle yes
(global-kkp-mode +1)
#+end_src


When select->paste delete selected text
#+begin_src emacs-lisp :tangle yes
(delete-selection-mode 1)
#+end_src

#+RESULTS:
: t

This determines the style of line numbers in effect. If set to `nil', line
numbers are disabled. For relative line numbers, ret this to `relative'.
#+begin_src emacs-lisp :tangle yes
(setq display-line-numbers-type 'relative)
#+end_src

#+RESULTS:
: relative

Cursor configs
#+begin_src emacs-lisp :tangle yes
(blink-cursor-mode 1) ; Blink cursor
(beacon-mode 1) ; Highlight cursor when scrolling/changing windows
#+end_src

#+RESULTS:
: t

Open maximized
#+begin_src emacs-lisp :tangle yes
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

#+RESULTS:
: ((fullscreen . maximized) (left-fringe . 8) (right-fringe . 8))

Remove hide keybinding
#+begin_src emacs-lisp :tangle yes
(global-unset-key (kbd "s-h"))
#+end_src

#+RESULTS:

*** OS-dependent

#+begin_src emacs-lisp :tangle yes
;Move to trash instead of deleting
(if (eq system-type 'darwin)
     (setq-default
  delete-by-moving-to-trash t))
#+end_src

#+RESULTS:
: t

** Minor tweaks
*** Encoding :unused:
UTF encoding
#+begin_src emacs-lisp :tangle yes
;; Obtained from
;; https://github.com/tecosaur/emacs-config/blob/master/config.org
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)

(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")
#+end_src

#+RESULTS:
: ► Doom

*** Write-or-die :unused:
#+begin_src emacs-lisp :tangle no
;; My own wee package to write
(load (concat doom-user-dir "local_packages/write-or-die.el"))
#+end_src

#+RESULTS:
: t
*** Yabai compatibility
Nix's Emacs version seems to give trouble.
#+begin_src emacs-lisp :tangle yes
(menu-bar-mode t)
#+end_src

#+RESULTS:
: t

** Explore options
#+begin_src emacs-lisp :tangle yes
(setq which-key-use-C-h-commands t)
#+end_src

** Terminal
Use path from shell when in GUI or daemon.
#+begin_src elisp :tangle yes
;; (when (or (memq window-system '(mac ns x)) )
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+end_src


* Dired
Add zip formats to default compression
#+begin_src emacs-lisp :tangle yes
(after! dired

  '(add-to-list 'dired-compress-file-suffixes
                 '("\\.zip\\'" ".zip" "unzip"))
   (map! :map dired-mode-map :gnv "h" 'dired-up-directory :gnv "l" 'dired-find-file)
   (setq dired-mouse-drag-files t))

(after! dirvish
  (setq dirvish-attributes
      '(vc-state subtree-state nerd-icons collapse git-msg file-time file-size))
  (setq dirvish-subtree-state-style 'nerd) )

#+end_src

#+RESULTS:
: nerd

** Dired icons
Add custom icons at the start of variable
#+begin_src emacs-lisp :tangle yes
(after! nerd-icons-dired
  (setf nerd-icons-dir-icon-alist (reverse (nconc (reverse nerd-icons-dir-icon-alist)
       (list
        '("films" nerd-icons-faicon "nf-fa-film")
        '("shows" nerd-icons-faicon "nf-fa-tv")
        '("games" nerd-icons-faicon "nf-fa-gamepad")
        '("books" nerd-icons-codicon "nf-cod-book")
        '("audiobooks" nerd-icons-faicon "nf-fa-headphones")
        '("courses" nerd-icons-mdicon "nf-md-school"))))))
#+end_src

** Dired-image
Adjust dired-image image-magic thumbnails
#+begin_src emacs-lisp :tangle yes
(setq image-dired-cmd-create-thumbnail-options (list  "-size" "%wx%h" "%f[0]" "-resize" "%wx%h>" "-strip" "-auto-level" "jpeg:%t"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(add-hook 'image-mode-hook
           (lambda nil
                (blimp-mode t)
                (blimp-interface-execute "auto-level")))
#+end_src

* Embark
#+RESULTS:

#+begin_src emacs-lisp :tangle yes
(map! "C-." 'embark-act)
(after! embark
 (eval-when-compile
   (defmacro my/embark-ace-action (fn)
     `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
        (interactive)
        (with-demoted-errors "%s"
          (require 'ace-window)
          (let ((aw-dispatch-always t))
            (aw-switch-to-window (aw-select nil))
            (call-interactively (symbol-function ',fn)))))))

 (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
 (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
  (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump)))

(after! ace-window
  (setq ace-window-display-mode t))
#+end_src

#+RESULTS:

* Projectile
Ignore my git in the $HOME Folder
#+begin_src emacs-lisp :tangle yes
(after! projectile
  (setq projectile-project-root-files-bottom-up
        (remove ".git" projectile-project-root-files-bottom-up)))



(setq projectile-project-search-path '("~/Documents/sync/projects"))


#+end_src

** Envrc
#+begin_src elisp :tangle yes
(require 'envrc)
(add-hook! (add-hook 'change-major-mode-after-body-hook 'envrc-mode))
#+end_src

#+RESULTS:

* Coding
** Tree-sitter
#+begin_src emacs-lisp :tangle yes
(global-tree-sitter-mode)
#+end_src

#+RESULTS:
: t

** Python

*** Venv
Python interpreter, completion and Inferior buferr settings
#+begin_src emacs-lisp :tangle yes
(after! python
(setq python-shell-interpreter "jupyter"
        python-shell-interpreter-args "console --simple-prompt"
        python-shell-prompt-detect-failure-warning nil)
(setq python-shell-completion-native-disabled-interpreters `(,@python-shell-completion-native-disabled-interpreters "jupyter"))
(add-hook 'python-mode-hook
          (lambda ()
            (setq-local python-shell-buffer-name
                        (format "Python %s"
                            (cadr (reverse (file-name-split (doom-modeline--project-root)))))))))

#+end_src

#+RESULTS:
| doom--setq-tab-width-for-python-mode-h | (lambda nil (setq-local python-shell-buffer-name (format Python %s (cadr (reverse (file-name-split (doom-modeline--project-root))))))) | er/add-python-mode-expansions | code-cells-mode-maybe | poetry-tracking-mode | +python-use-correct-flycheck-executables-h | evil-collection-python-set-evil-shift-width | doom-modeline-env-setup-python | (lambda nil (set (make-local-variable 'python-shell-buffer-name) (format Python %s (car (cdr (reverse (file-name-split (doom-modeline--project-root)))))))) | pipenv-mode | +lookup-init--set-python-mode |

Functions used for code-cells functionality
#+begin_src emacs-lisp :tangle yes
(after! python
  (add-hook! python-mode (add-hook 'python-mode-hook 'code-cells-mode-maybe))
  (add-hook! python-mode (add-hook 'before-save-hook 'lsp-organize-imports nil t))
  (add-hook! python-mode (add-hook 'before-save-hook 'lsp-format-buffer nil t))

 (defun previous-line-empty-p ()
   "Check if immediate previous line is empty.
  If region is active it checks from the region beginning.
  Useful to add extra \newlines to yasnippets."
   (if (region-active-p)
       (save-excursion (goto-char (region-beginning))
                       (line-before-pointer-empty-p))
     (line-before-pointer-empty-p)))


 (defun line-before-pointer-empty-p ()
   "Check if the line immediately before the pointer is empty."
   (save-excursion (forward-line -1)
                   (current-line-empty-p))))
#+end_src

*** Debug
**** Realgud
Simple but reliable
  #+begin_src emacs-lisp :tangle yes
(setq realgud:pdb-command-name "python -m ipdb")
;; (setq realgud:pdb-command-name "pytest -s --trace")
(defun realgud-pdb-pytest nil
  (interactive)
  (realgud:pdb (concat "pytest --trace --color=yes " buffer-file-name)))

  #+end_src


#+begin_src emacs-lisp :tangle no
(after! pdb-track
(defface term-color-darkgreen
'((t :foreground "DarkGreen" :background "DarkGreen"))
"Face used to render dark green color code."
:group 'term)
(defface term-color-cadetblue
'((t :foreground "CadetBlue" :background "CadetBAlue"))
"Face used to render dark cadet blue color code."
:group 'term)

(defface term-color-purple
'((t :foreground "Purple" :background "Purple"))
"Face used to render dark Purple color code."
:group 'term)

(defface term-color-darkgoldenrod
'((t :foreground "Darkgoldenrod" :background "Darkgoldenrod"))
"Face used to render dark Darkgoldenrod color code."
:group 'term)

(defface term-color-ivory4
'((t :foreground "Ivory4" :background "Ivory4"))
"Face used to render dark Ivory4 color code."
:group 'term)

(setq ansi-term-color-vector
[term
term-color-black
term-color-red
term-color-darkgreen
term-color-cadetblue
term-color-blue
term-color-purple
term-color-darkgoldenrod
term-color-ivory4]))
#+end_src

#+RESULTS:

**** Unused
Debugging tools
#+begin_src emacs-lisp :tangle yes
(after! realgud
  (defun describe-at-cursor()
    "Describe variable at cursor when using debugger"
    (interactive)
    (realgud:cmd-info-value (concat (thing-at-point 'word) "\n")))
  ;; (realgud:cmd-info-value (concat (looking-at (regexp-quote "[a-z][a-z]")) "\n") ))

  (map! :localleader :map realgud:shortkey-mode-map "_" 'describe-at-cursor)
  (map! :localleader :map realgud-track-mode-map "a" 'realgud:attach-source-buffer))
  #+end_src

  #+RESULTS:

*** REPL
  #+begin_src emacs-lisp :tangle yes
  (defun python-shell-send-current-statement ()
    "Send current statement to Python shell.
Taken from elpy-shell-send-current-statement"
    (interactive)
    (let ((beg (python-nav-beginning-of-statement))
          (end (python-nav-end-of-statement)))
      (python-shell-send-string (buffer-substring beg end)))
    (python-nav-forward-statement))

#+end_src

#+RESULTS:
: python-shell-send-current-statement

*** Custom
#+begin_src emacs-lisp :tangle yes

  ;; My own functions to deal with python code
  (require 'cl-lib)

  (defun get-current-line ()
    (buffer-substring-no-properties (line-beginning-position)
                                    (line-end-position)))


  (defun parse-current-pylambda-line ()
    "Fetch indentation, name, args and returns from a pylambda function"

    (cl-multiple-value-bind (preequal posequal) (split-string ( get-current-line ) "\=")
      (cl-multiple-value-bind (lambda-args post-return) (split-string posequal "\\:")
        (list
         (length (butlast (split-string preequal " ") 2))
         (car (last (butlast (split-string preequal " ") 1)))
         (string-replace "," ", " (string-replace " " "" (string-replace "lambda" "" (string-replace "λ" "lambda" lambda-args))))
         post-return))))

  (defun pylambda-parse-to-def ()
    "Parses pylambda one-liners and produces a def equivalent.

       FIXME Fails on this case:

       savgol_on_srs = lambda x: non_uniform_savgol(
            x.index, x.values, window, degree
        )


"
    (cl-multiple-value-bind (indentation fn-name args return) (parse-current-pylambda-line)
      ;; (message "%s" indentation)
      (concat
       (mapconcat 'identity (cl-loop repeat indentation collect " ") "")
       "def " fn-name "(" args "):\n"
       (mapconcat 'identity (cl-loop repeat (+ indentation 4) collect " ") "")
       "return" return "\n")))

  (defun replace-pylambda-with-def ()
    "Delete the current (lambda being assigned to a variable) line and replace it with a def definition to follow flake8's E731 rule."
    (interactive)
    (let ((def-string (pylambda-parse-to-def)))
      (kill-whole-line)
      (insert def-string)))


#+end_src

#+RESULTS:
: replace-pylambda-with-def

*** Code-cells

**** Python
#+begin_src elisp :tangle yes
   (map! :map python-mode-map
         :localleader
         :n "z" #'run-python
         "w" #'venv-workon-and-update
         "y" #'realgud:pdb
         "f" #'realgud-pdb-pytest

         (:desc "send to REPL" :prefix "s"
                "r" #'python-shell-send-region-or-line
                "b" #'python-shell-send-buffer
                "d" #'python-shell-send-defun))

   (defun python-shell-send-region-or-line nil
     "Sends from python-mode buffer to a python shell, intelligently."
     (interactive)
     (cond ((region-active-p)
            (setq deactivate-mark t)
            (python-shell-send-region (region-beginning) (region-end)))
           (t (python-shell-send-current-statement))))
#+end_src

#+RESULTS:
: python-shell-send-region-or-line

#+begin_src emacs-lisp :tangle yes

(after! code-cells
  (map! :map code-cells-mode-map
        :desc "Navigate to next cell" :n "n" (code-cells-speed-key 'code-cells-forward-cell)
        :desc "Navigate to previous cell" :n "p" (code-cells-speed-key 'code-cells-backward-cell)
        :desc "Eval until this cell" :n "u" (code-cells-speed-key 'code-cells-eval-above)
        :desc "Eval current cell" :n "e" (code-cells-speed-key 'code-cells-eval)
        :n "TAB" (code-cells-speed-key 'outline-cycle)
        :n ";" (code-cells-speed-key 'code-cells-comment-or-uncomment)

        ;; Map additional keys using local-leader to better suit my live-testing
        ;; workflow.
        :localleader
        :desc "eval current cell" :n "e" #'code-cells-eval
        :desc "navigate to previous cell" :n "k" #'code-cells-backward-cell
        :desc "Navigate to next cell" :n "j" #'code-cells-forward-cell
        :desc "Eval until this cell" :n "u" #'code-cells-eval-above))

#+end_src
#+RESULTS:


*** LSP
pylsp seems to be enabled by default; ruff-lsp is much better
#+begin_src emacs-lisp :tangle yes
(setq lsp-disabled-clients '(pylsp pyright))
#+end_src

#+RESULTS:

** Common Lisp

Open after list
#+begin_src emacs-lisp :tangle yes
(after! lispyville
  (defun lispyville-open-after-list ()
    (interactive)
    (lispyville-next-closing)
    (evil-append 0)))
#+end_src

#+RESULTS:

*** Keybindings
#+begin_src emacs-lisp :tangle yes
(after! lispyville
  (map!
   :map lispyville-mode-map
   ;; :n "(" #'lispyville-wrap-with-round)
   :n "(" #'lispyville-wrap-round
   :n "M-(" #'lispyville-wrap-with-round
   :n "M-k" #'lispyville-open-after-list))

(after! flyspell
  (setq ispell-personal-dictionary (substitute-in-file-name "$HOME/.aspell.en.pws")))

#+end_src

#+RESULTS:
: t

** Others
*** Julia
#+begin_src emacs-lisp :tangle yes

(after! julia
  (map! :map julia-mode-map
        :localleader
        :n "z" #'run-julia

        (:desc "send to REPL" :prefix "s"
               "r" #'julia-repl-send-region-or-line
               "b" #'julia-repl-send-buffer)))

#+end_src

#+RESULTS:
*** Racklet
#+begin_src elisp :tangle yes
(defun my-backward-up-sexp (a)
  "my backwards up sexps.
   prefix command interpretation:
     0    → to beginning of all nested sexps
     -    → to end of all nested sexps
     x|+x → x-times go back out of sexps to beginning
     -x   → x-times go out of sexps to end
     universal-command interpreted as +x"
  (interactive "P")
  (condition-case err
      (let ((arg)
            (loop))
        (cond
         ((null a) ;; back-up once
          (setq arg -1
                loop nil))
         ((eq a '-) ;; up to end of all sexps
          (setq arg 1
                loop t))
         ((numberp a)
          (cond
           ((= a 0) ;; back-up to begin of all sexps
            (setq arg -1
                  loop t))
           (t (setq arg (- a) ;; do it a times
                    loop nil))))
         (t (setq arg (- (car a)) ;; interpret `universal-command'
                  loop nil)))
        (while (progn  ;; do-while loop
                 (up-list arg t t)
                 loop)))
    (scan-error ;; stay quiet
     nil)))

(after! racket
   (defun racket-send-region-or-line nil
     "Sends from racket-mode buffer to a racket shell, intelligently."
     (interactive)
     (if (region-active-p) (progn
                            (setq deactivate-mark t)
                            (racket-send-region (region-beginning) (region-end)))
           (save-mark-and-excursion (beginning-of-defun) (set-mark (point)) (end-of-defun)
               (racket-send-region (region-beginning) (region-end)))))
   (map! :localleader :map racket-mode-map "s r" 'racket-send-region-or-line)
    )





#+end_src

#+RESULTS:
*** SCAD :unused:
Openscad autoformatter
#+begin_src emacs-lisp :tangle no
(set-formatter! 'scadfmt "clang-format" :modes '(scad-mode))
#+end_src

#+RESULTS:
: scadfmt

* Reading
#+begin_src emacs-lisp :tangle yes
(setq doc-view-continuous t)
(setq doc-view-resolution 400)
#+end_src

#+RESULTS:
: 300

** Elfeed
*** Style
Change font for elfeed-show buffer.
#+begin_src elisp :tangle yes
(setq elfeed-font (if (member "Mebinac" (font-family-list)) "Mebinac" "Century Schoolbook"))
(setq elfeed-show-mode-hook
      (lambda ()
          (set-face-attribute 'variable-pitch (selected-frame) :font (font-spec :family elfeed-font :size 16))
        ))
#+end_src

#+RESULTS:
| lambda | nil | (set-face-attribute 'variable-pitch (selected-frame) :font (font-spec :family elfeed-font :size 16)) |

*** elfeed-org
#+begin_src emacs-lisp :tangle yes

(setq rmh-elfeed-org-files (list (concat org-directory "personal/rss/elfeed.org")))

(after! elfeed
  (setq elfeed-search-filter "@2-weeks-ago +unread")
  (add-hook 'elfeed-search-mode-hook #'elfeed-update)


(defun find-in-elfeed-org-file ()
  "Find elfeed-show-entry in the first elfeed-org file"
      (interactive)
      (let* ((elfeed-show-entry-id (car (elfeed-entry-id elfeed-show-entry)))
            (elfeed-default-org-file (car rmh-elfeed-org-files))
            (elfeed-window (get-buffer-window (file-name-nondirectory elfeed-default-org-file))))

       (if (not elfeed-window) ; Open elfeed org file if not visible
         (progn
           (select-window (get-buffer-window "*elfeed-search*"))
           (let ((w (split-window-below)))
             (select-window w)
             (find-file elfeed-default-org-file)))
         (select-window elfeed-window))

       (or ;; Search pattern forward and backward
        (or (search-forward elfeed-show-entry-id nil t)
               (search-backward elfeed-show-entry-id nil t))
          (message
           (concat elfeed-show-entry-id " not found in elfeed-org file " elfeed-default-org-file)))))

(defun elfeed-eww-about ()
  "Open about page of elfeed entry in eww."
  (interactive)
  (eww-browse-url (concat "https://" (car (elfeed-entry-id elfeed-show-entry)) "/about")))

  (setq elfeed-goodies/entry-pane-size 0.6)
  (setq elfeed-goodies/log-window-size 0.4))

;; (after! elfeed
;;  (setq elfeed-score-serde-score-file (substitute-in-file-name "$HOME/.doom.d/elfeed.score")))
#+end_src

#+RESULTS:
: @2-weeks-ago +unread

Format headers buffer
#+begin_src emacs-lisp :tangle no
(defun concatenate-authors (authors-list)
  "Given AUTHORS-LIST, list of plists; return string of all authors
concatenated."
  (mapconcat
   (lambda (author) (plist-get author :name))
   authors-list ", "))
(defun my-search-print-fn (entry)
  "Print ENTRY to the buffer."
  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title)
                    (elfeed-entry-title entry) ""))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title
          (when feed
            (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
         (entry-authors (concatenate-authors
                         (elfeed-meta entry :authors)))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags-str (mapconcat
                    (lambda (s) (propertize s 'face
                                            'elfeed-search-tag-face))
                    tags ","))
         (title-width (- (window-width) 10
                         elfeed-search-trailing-width))
         (title-column (elfeed-format-column
                        title (elfeed-clamp
                               elfeed-search-title-min-width
                               title-width
                               elfeed-search-title-max-width)
                        :left))
         (authors-width 135)
         (authors-column (elfeed-format-column
                          entry-authors (elfeed-clamp
                                         elfeed-search-title-min-width
                                         authors-width
                                         131)
                          :left)))

    (insert (propertize date 'face 'elfeed-search-date-face) " ")

    (insert (propertize title-column
                        'face title-faces 'kbd-help title) " ")

    (insert (propertize authors-column
                        'face 'elfeed-search-date-face
                        'kbd-help entry-authors) " ")

    ;; (when feed-title
    ;;   (insert (propertize entry-authors
    ;; 'face 'elfeed-search-feed-face) " "))

    (when entry-authors
      (insert (propertize feed-title
                          'face 'elfeed-search-feed-face) " "))

    (when tags
      (insert "(" tags-str ")"))))




(setq elfeed-search-print-entry-function #'my-search-print-fn)

#+end_src

#+RESULTS:
: my-search-print-fn
*** HN
Show HN comments in elfeed
#+begin_src emacs-lisp :tangle yes
(defun my/elfeed-hn-show-comments-at-point ()
  "Show HN comments for an URL at point"
  (interactive)
  (setq-local hnreader-view-comments-in-same-window t)
  (hnreader-comment (format "%s" (url-get-url-at-point))))

(defun my/elfeed-hn-show-commments (&optional link)
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (if link link (elfeed-entry-link entry))))
    (setq-local hnreader-view-comments-in-same-window nil)
    (hnreader-comment (format "%s" link))))

(defun my/elfeed-fetch-ids ()
  (interactive)
  (cl-loop for entry in (elfeed-search-selected)
           collect (elfeed-entry-id entry)))

(defun my/elfeed-hn-show-comments-at-entry ()
  (interactive)
  (let ((id-value (car (my/elfeed-fetch-ids))))
    (if  (string= (car id-value) "hnrss.org")
        (progn (elfeed-search-untag-all-unread) (hnreader-comment (cdr id-value)))
      (elfeed-search-show-entry))))
#+end_src

#+RESULTS:
: my/elfeed-hn-show-comments-at-entry

Shortcuts
#+begin_src emacs-lisp :tangle yes
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      ;; ...
      :n "H" #'my/elfeed-hn-show-commments)
(map! :map elfeed-search-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      ;; ...
      :n "H" #'my/elfeed-hn-show-comments-at-entry)

#+end_src

#+RESULTS:

*** Reddit
Integrate to elfeed
#+begin_src emacs-lisp :tangle no
(defun my/elfeed-reddit-show-commments (&optional link)
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                    elfeed-show-entry
                  (elfeed-search-selected :ignore-region)))
         (link (if link link (elfeed-entry-link entry))))
    (reddigg-view-comments link)))
#+end_src
Shortcuts
#+begin_src emacs-lisp :tangle no
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      ;; ...
      :n "R" #'my/elfeed-reddit-show-commments
      )
#+end_src

*** Conveniences
#+begin_src elisp :tangle yes
(defun kill-elfeed-show-url ()
  (interactive)
  (kill-new (elfeed-entry-link elfeed-show-entry))
  )

(map! :localleader :map elfeed-show-mode-map  "y" #'kill-elfeed-show-url)
#+end_src

#+RESULTS:

** Mu4e
#+begin_src emacs-lisp :tangle yes
(after! mu4e
  (setq +mu4e-backend 'offlineimap)

;;; Call the oauth2ms program to fetch the authentication token
  (defun fetch-access-token ()
    (with-temp-buffer
      (call-process "oauth2ms" nil t nil "--encode-xoauth2")
      (buffer-string)))

 ;;; Add new authentication method for xoauth2
  (cl-defmethod smtpmail-try-auth-method
    (process (_mech (eql xoauth2)) user password)
    (let* ((access-token (fetch-access-token)))
      (smtpmail-command-or-throw
       process
       (concat "AUTH XOAUTH2 " access-token)
       235)))

 ;;; Register the method
  (with-eval-after-load 'smtpmail
    (add-to-list 'smtpmail-auth-supported 'xoauth2))

  (setq message-send-mail-function 'smtpmail-send-it
        starttls-use-gnutls t
        smtpmail-starttls-credentials
        ;; '(("smtp.office365.com" 587 nil nil))
        '(("smtp.office365.com" 587 nil nil))
        smtpmail-default-smtp-server "smtp.office365.com"
        smtpmail-smtp-server "smtp.office365.com"
        smtpmail-stream-type  'starttls
        ;; smtpmail-smtp-service 587
        smtpmail-smtp-service 587
        smtpmail-debug-info t)

  (add-to-list 'mu4e-bookmarks
               '( :name  "Peter non-lab"
                  :query "from:Peter and not lab"
                  :key   ?t))
  )
 #+end_src

 #+RESULTS:

** GNUS
I aim to Merge RSS and Mail reading
#+begin_src emacs-lisp :tangle yes
;; (add-to-list 'gnus-secondary-select-methods
;;              '(nntp "news.gwene.org"))
#+end_src
Format gnus summary
#+begin_src emacs-lisp :tangle yes
(setq gnus-summary-line-format "%U%R%z%d %I%(%[ %F %] %s %)\n")
#+end_src
Atom -> RSS
#+begin_src emacs-lisp :tangle yes
(require 'mm-url)
(defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  "Converts atom to RSS by calling xsltproc."
  (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\""
			   nil t)
    (goto-char (point-min))
    (message "Converting Atom to RSS... ")
    (call-process-region (point-min) (point-max)
			 "xsltproc"
			 t t nil
			 (expand-file-name "~/atom2rss.xsl") "-")
    (goto-char (point-min))
    (message "Converting Atom to RSS... done")))

(ad-activate 'mm-url-insert)
#+end_src
** Newsticker
#+begin_src emacs-lisp :tangle yes
(setq newsticker-url-list
      '(("Emacs SE"
         "https://emacs.stackexchange.com/feeds")))
#+end_src

* Org
** Basic
#+begin_src emacs-lisp :tangle yes
(setq org-M-RET-may-split-line nil)
#+end_src
** Aesthetics
Org-modern
#+begin_src emacs-lisp :tangle yes

(after! org-modern
 (setq
  ;; Edit settings
  org-auto-align-tags nil
  org-tags-column 0
  org-catch-invisible-edits 'show-and-error
  org-special-ctrl-a/e t
  org-insert-heading-respect-content nil

  ;; Org styling, hide markup etc.
  org-hide-emphasis-markers t
  org-pretty-entities t
  org-ellipsis "…"

  ;; Agenda styling
  org-agenda-tags-column 0
  org-agenda-block-separator ?─
  org-agenda-time-grid
  '((daily today require-timed)
    (800 1000 1200 1400 1600 1800 2000)
    " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
  org-agenda-current-time-string
  "⭠ now ─────────────────────────────────────────────────"))

;; (add-hook 'org-mode-hook #'org-modern-mode)
;; (add-hook 'org-agenda-finalize-hook #'org-modern-agenda)

#+end_src

Main org directory
#+begin_src emacs-lisp :tangle yes
(setq org-directory "~/Documents/sync/org/")
#+end_src

#+RESULTS:
: ~/Documents/sync/org/

#+begin_src emacs-lisp :tangle yes

;; Other convenience shortcuts
;; Don't kill on paste
 (setq-default evil-kill-on-visual-paste nil)

;; Evil copy and comment
(map! :map evil-normal-state-map "g C" 'evilnc-copy-and-comment-lines)
(setq evil-move-beyond-eol t)

;; Give me back C-u
(setq evil-want-C-u-scroll nil
       evil-want-C-d-scroll nil
       evil-want-C-u-delete nil
 )


; kill current buffer faster
(map! "C-x k" 'kill-current-buffer)
(map! "C-x K" 'kill-buffer)
#+end_src

#+RESULTS:

** General text shenanigans
***  Paragraph list
Convenience functions to generate explore-paragraph
#+begin_src emacs-lisp :tangle yes
(defun current-line-empty-p ()
  "Check if current line is empty."
  (save-excursion
    (beginning-of-line)
    (looking-at-p "[[:space:]]*$")))

(defun rest-of-line-empty-p ()
  (interactive)
  (save-excursion
    (if (looking-at-p "[[:space:]]*$") (message "empty"))))

#+end_src

#+RESULTS:
: rest-of-line-empty-p

Main explode-paragraph function
#+begin_src emacs-lisp :tangle yes
(defun explode-paragraph (&optional monolevel)
    "explode paragraph, more documentation needed"
    (interactive)
    (unless monolevel ( setq monolevel nil))
    (save-mark-and-excursion
      (when (save-excursion (forward-line -1) (and (message-point-in-header-p) (not (current-line-empty-p )))) (newline-and-indent))
      (let ((bop (copy-marker (progn (backward-paragraph) (1+ (point)))))
            (eop (copy-marker (progn (forward-paragraph)  (point))))
            (inc-level 0))
        (goto-char bop)
        (if (looking-at-p "^\s*[\-\+x] ") nil (insert "+ "))
        (while (< (point) eop)
          (forward-sentence)
          (if (not (save-excursion ( forward-char -3 ) (looking-at-p "\\.[a-z]\\.")))
              (progn
                (forward-whitespace 1)
                (unless (>= (point) eop)
                  (org-meta-return)
                  (when (and (eq inc-level 0) (not monolevel))
                    (progn ( org-metaright ) (setq inc-level 1))))))))))
#+end_src

#+RESULTS:
: explode-paragraph

Generate toggle function and map
#+begin_src emacs-lisp :tangle yes
  (defun toggle-paragraph-list ()
    (interactive)
    (if (org-in-item-p) (myorg-list-to-text) (explode-paragraph)))
  ;;Keybindings
  (map! :localleader :map org-mode-map "u" 'toggle-paragraph-list)
#+end_src

#+RESULTS:

*** Get text
Copy org url
#+begin_src emacs-lisp :tangle yes
(defun my-org-retrieve-url-from-point ()
  "Copies the URL from an org link at the point"
  (interactive)
  (let ((plain-url (url-get-url-at-point)))
    (if plain-url
        (progn
          (kill-new plain-url)
          (message (concat "Copied: " plain-url)))
      (let* ((link-info (assoc :link (org-context)))
             (text (when link-info
                     (buffer-substring-no-properties
                      (or (cadr link-info) (point-min))
                      (or (caddr link-info) (point-max))))))
        (if (not text)
            (error "Oops! Point isn't in an org link")
          (string-match org-link-bracket-re text)
          (let ((url (substring text (match-beginning 1) (match-end 1))))
            (kill-new url)
            (message (concat "Copied: " url))))))))

(after! org
  (map! :map org-mode-map
        :localleader
        (:prefix ("l" . "links")
         "y" #'my-org-retrieve-url-from-point)))

#+end_src

#+RESULTS:

*** Sort trees recursively
#+begin_src emacs-lisp :tangle yes
(defun ap/org-sort-entries-recursive (&optional key)
  "Call `org-sort-entries' recursively on tree at point.
If KEY, use it; otherwise read key interactively.
From https://www.reddit.com/r/orgmode/comments/o2df99/automatically_recursively_sorting_an_org_file/
"
  (interactive)
  (cl-macrolet ((moves-p (form)
                         `(let ((pos-before (point)))
                            ,form
                            (/= pos-before (point)))))
    (cl-labels ((sort-tree
                 () (cl-loop do (when (children-p)
                                  (save-excursion
                                    (outline-next-heading)
                                    (sort-tree))
                                  (org-sort-entries nil key))
                             while (moves-p (org-forward-heading-same-level 1))))
                (children-p (&optional invisible)
                            ;; Return non-nil if entry at point has child headings.
                            ;; Only children are considered, not other descendants.
                            ;; Code from `org-cycle-internal-local'.
                            (save-excursion
                              (let ((level (funcall outline-level)))
                                (outline-next-heading)
                                (and (org-at-heading-p t)
                                     (> (funcall outline-level) level))))))
      (save-excursion
        (save-restriction
          (widen)
          (unless key
            ;; HACK: Call the sort function just to get the key, then undo its changes.
            (cl-letf* ((old-fn (symbol-function 'read-char-exclusive))
                       ((symbol-function 'read-char-exclusive)
                        (lambda (&rest args)
                          (setf key (apply #'funcall old-fn args)))))
              ;; Sort the first heading and save the sort key.
              (org-sort-entries))
            (undo-only))
          (cond ((org-before-first-heading-p)
                 ;; Sort whole buffer. NOTE: This assumes the first heading is at level 1.
                 (org-sort-entries nil key)
                 (outline-next-heading)
                 (cl-loop do (sort-tree)
                          while (moves-p (org-forward-heading-same-level 1))))
                ((org-at-heading-p)
                 ;; Sort this heading.
                 (sort-tree))
                (t (user-error "Neither on a heading nor before first heading"))))))))

(defun ap/org-sort-entries-recursive-multi (&optional keys)
  "Call `ap/org-sort-entries-recursive'.
If KEYS, call it for each of them; otherwise call interactively
until \\[keyboard-quit] is pressed."
  (interactive)
  (if keys
      (dolist (key keys)
        (ap/org-sort-entries-recursive key))
    (with-local-quit
      ;; Not sure if `with-local-quit' is necessary, but probably a good
      ;; idea in case of recursive edit.
      (cl-loop while (progn
                       (call-interactively #'ap/org-sort-entries-recursive)
                       t)))))
#+end_src
** Roam
#+begin_src emacs-lisp :tangle yes

;; Org-roam settings
(setq org-roam-directory "~/Documents/sync/org/roam/")
(require 'org-roam-protocol)

;; Fix dired buffer not working with roam
;; (add-hook 'dired-mode-hook
;;           (lambda ()
;;             (org-roam-mode 0)))


;; org-roam settings
(setq org-roam-capture-templates
      '(("r" "reference" plain "%?"
         :if-new (file+head "references/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+roam_tags: reference\n")
         :immediate-finish t)
        ("c" "concept" plain "%?"
         :if-new (file+head "concept/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+roam_tags: concept\n")
         :immediate-finish t
         :unnarrowed t)
        ("m" "main" plain "%?"
                :if-new (file+head "main/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+roam_tags: main\n")
         :immediate-finish t
         :unnarrowed t)
        ("i" "idea" plain "%?"
                :if-new (file+head "ideas/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+roam_tags: idea\n")
         :immediate-finish t
         :unnarrowed t)
        ("a" "article" plain "%?"
         :if-new (file+head "articles/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+roam_tags: article\n")
         :immediate-finish t
         :unnarrowed t)))

(use-package! websocket
    :after org-roam)
#+end_src

*** Org-roam ui
Interface to visualise a personal database.
#+begin_src emacs-lisp :tangle no
(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

;; ;; org-roam-server configs
;; (use-package org-roam-server
;;   :ensure t
;;   :config
;;   (setq org-roam-server-host "127.0.0.1"
;;         org-roam-server-port 8080
;;         org-roam-server-authenticate nil
;;         org-roam-server-export-inline-images t
;;         org-roam-server-serve-files nil
;;         org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
;;         org-roam-server-network-poll t
;;         org-roam-server-network-arrows nil
;;         org-roam-server-network-label-truncate t
;;         org-roam-server-network-label-truncate-length 60
;;         org-roam-server-network-label-wrap-length 20))

;; (setq org-roam-db-update-method 'immediate)

#+end_src

#+RESULTS:
| r | reference | plain | %? | :if-new | (file+head references/%<%Y%m%d%H%M%S>-${slug}.org #+title: ${title} |

** Org-export
*** Markdown
Add it to enabled exports, since at some point it stopped being loaded by default
#+begin_src emacs-lisp :tangle yes
(after! org
   '(require 'ox-gfm nil t)
    (add-to-list 'org-export-backends 'md )
    (add-to-list 'org-export-backends 'gfm )
)
#+end_src

#+RESULTS:
| gfm | pandoc | beamer | md | ascii | html | icalendar | latex | odt |

*** References
#+begin_src emacs-lisp :tangle yes
(after! org
(customize-set-value 'org-latex-with-hyperref nil)
(add-to-list 'org-latex-default-packages-alist "\\PassOptionsToPackage{hyphens}{url}"))
#+end_src

#+RESULTS:
| \PassOptionsToPackage{hyphens}{url} | ( amsmath t (lualatex xetex)) | ( fontspec t (lualatex xetex)) | (AUTO inputenc t (pdflatex)) | (T1 fontenc t (pdflatex)) | ( graphicx t) | ( longtable nil) | ( wrapfig nil) | ( rotating nil) | (normalem ulem t) | ( amsmath t (pdflatex)) | ( amssymb t (pdflatex)) | ( capt-of nil) | ( hyperref nil) |

***  Bibliography
#+begin_src emacs-lisp :tangle yes
(after! org
 (setq org-log-done 'time)

 (use-package citar
   :no-require
   :custom
   (org-cite-global-bibliography '("~/Documents/sync/bibliography/bibliography.bib" "~/Documents/sync/bibliography/mac_bibliography.bib"))
   (org-cite-insert-processor 'citar)
   (org-cite-follow-processor 'citar)
   (org-cite-activate-processor 'citar)
   (citar-bibliography org-cite-global-bibliography)
   (org-cite-csl-styles-dir
    (expand-file-name "~/Zotero/styles/"))
     (map! "SPC n B" citar-open-files)))




#+end_src

#+RESULTS:


OX-extra for citations to work properly
It is also required for :ignore: flags to work properly
#+begin_src emacs-lisp :tangle yes
(use-package! ox-extra
  :after org
  :config
  (ox-extras-activate '(ignore-headlines))

  (use-package! citeproc-org
    :config
    (citeproc-org-setup)
    (require 'oc-csl))
  ;; ox-hugo configs
  (use-package! ox-hugo
    :after org)

  (use-package! citeproc-org
    :after ox-hugo
    :config
    (citeproc-org-setup))

;; TODO confirm this is necessary
  (setq org-cite-basic-author-column-end  100))

#+end_src

#+RESULTS:
: 100

***  Glossary
Add shortcuts to add referentiable acronyms and glossary
 #+begin_src emacs-lisp :tangle yes

(after! org
 (map! :localleader :map org-mode-map
       "l a" #'org-ref-insert-acronym-link
       "l g" #'org-ref-insert-glossary-link)
 )

#+end_src

#+RESULTS:


Maybe expand glossary formatting in the future
#+begin_src emacs-lisp :tangle yes
;; (setf org-ref-glossary-gls-commands
;;       (append  org-ref-glossary-gls-commands
;;                '( ("glslbl"  "The associated label (generally the accronym)"))))

#+end_src

#+RESULTS:
** Text-based shenanigans

Function to toggle between paragraphs and bullet points whose first sentence is at a higher level.

#+begin_src emacs-lisp :tangle yes
  (defun next-nonblank-line ()
    (interactive)
    (forward-line)
    (skip-chars-forward "[:space:]"))


  (defun previous-nonblank-line ()
    (interactive)
    (forward-line -1)
    (when (current-line-empty-p)
      (beginning-of-line)
      (skip-chars-backward "[:space:]")))


  (defun lower-level-p ()
    (interactive)
    "Return true if there is a lower level"
    (save-excursion
      (org-end-of-line)
      (org-beginning-of-line)
      (let ((current-col (current-column))
            (next-line-col (save-excursion (next-nonblank-line) (org-end-of-line) (org-beginning-of-line) (current-column)))
            (lower-level-exists nil))
        (if (> next-line-col current-col)
            (progn (setq lower-level-exists 1) (message "Not a leaf node"))
          (message "Leaf node"))
        lower-level-exists)))

  (defun myorg-list-to-text ()
    (interactive)
    "Transform item list at point into section text.
      Searches for the next item list if there is none at point."
    (save-mark-and-excursion
      (if (lower-level-p) (next-nonblank-line))
      (unless (org-in-item-p)
        (org-list-search-forward (org-item-beginning-re)))
      (set-mark (org-end-of-item-list))
      (previous-nonblank-line)
      (org-beginning-of-item-list)
      (when (org-at-item-checkbox-p)
        (org-toggle-checkbox '(4)))
      (org-toggle-item nil)
      (previous-nonblank-line)
      (org-toggle-item nil)
      (unfill-paragraph)))


  (map! :map org-mode-map "M-Q" 'unfill-paragraph)

  (defun my-eval-string (string)
    (eval (car (read-from-string (format "(progn %s)" string)))))

  (defun eval-last-yanked ()
    "Evaluate last yanked expression"
    (interactive)
    (my-eval-string (current-kill 0)))


#+end_src

#+RESULTS:
: eval-last-yanked

Export
#+begin_src emacs-lisp :tangle no

;; Long Tables
(setq org-export-before-parsing-functions '(org-ref-glossary-before-parsing org-ref-acronyms-before-parsing))

#+end_src

#+RESULTS:
| org-ref-glossary-before-parsing | org-ref-acronyms-before-parsing |

** Write checks

*** Language Tool
To set this up on the computer install from [[https://github.com/languagetool-org/languagetool#scripted-installation-and-building][here]] and then set link this variable to the tool jar
#+begin_src emacs-lisp :tangle yes
;; For arch
(setq langtool-java-classpath nil)
;; Manually installed, for ubuntu
;; Cover both macos and ubuntu locations
(setq langtool-language-tool-jar (if (file-expand-wildcards "/home/alan/opt/LanguageTool-*/languagetool-commandline.jar") (file-expand-wildcards "/opt/LanguageTool-*/languagetool-commandline.jar")))

;; Show suggestions in pop-up window
(defun langtool-autoshow-detail-popup (overlays)
    (when (require 'popup nil t)
      ;; Do not interrupt current popup
      (unless (or popup-instances
                  ;; suppress popup after type `C-g` .
                  (memq last-command '(keyboard-quit)))
        (let ((msg (langtool-details-error-message overlays)))
          (popup-tip msg)))))

  (setq langtool-autoshow-message-function
        'langtool-autoshow-detail-popup)

  ;; Add local language and rules ignored
  (setq langtool-default-language "en-GB")
  (setq langtool-disabled-rules '(
                                  "OXFORD_SPELLING_Z_NOT_S"
                                  "WHITESPACE_RULE"
                                  "CURRENCY"))
#+end_src

#+RESULTS:
| OXFORD_SPELLING_Z_NOT_S | WHITESPACE_RULE | CURRENCY |

** Agenda
#+begin_src emacs-lisp :tangle yes
  (defun org-make-olist (arg)
    (interactive "P")
    (let ((n (or arg 1)))
      (when (region-active-p)
        (setq n (count-lines (region-beginning)
                             (region-end)))
        (goto-char (region-beginning)))
      (dotimes (i n)
        (beginning-of-line)
        (insert (concat (number-to-string (1+ i)) ". "))
        (forward-line))
      (beginning-of-line)))

  (setq org_notes "~/Documents/sync/org/roam/"
        zotero_bib "~/Documents/sync/PhD/bibliography/references.bib"
        org-time-stamp-formats
        '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M:%S>")
        ;; org-agenda-files '("~/Documents/sync/org/gtd/inbox.org"
        ;;                    "~/Documents/sync/org/gtd/gtd.org"
        ;;                    "~/Documents/sync/org/gtd/tickler.org")
        ;; org-refile-targets '(("~/Documents/sync/org/gtd/gtd.org" :maxlevel . 3)
        ;;                      ("~/Documents/sync/org/gtd/someday.org" :level . 1)
        ;;                      ("~/Documents/sync/org/gtd/tickler.org" :maxlevel . 2))
        )

(defun unpackaged/org-forward-to-entry-content (&optional unsafe)
  "Skip headline, planning line, and all drawers in current entry.
If UNSAFE is non-nil, assume point is on headline."
  (unless unsafe
    ;; To improve performance in loops (e.g. with `org-map-entries')
    (org-back-to-heading))
  (cl-loop for element = (org-element-at-point)
           for pos = (pcase element
                       (`(headline . ,_) (org-element-property :contents-begin element))
                       (`(,(or 'planning 'property-drawer 'drawer) . ,_) (org-element-property :end element)))
           while pos
           do (goto-char pos)))

(defun my-org-files-list ()
  (delq nil
    (mapcar (lambda (buffer)
      (buffer-file-name buffer))
      (org-buffer-list 'files t))))

#+end_src
#+begin_src emacs-lisp :tangle yes
(setq org-refile-targets '((my-org-files-list :maxlevel . 4)))
#+end_src

#+RESULTS:
: ((my-org-files-list :maxlevel . 4))

** Tables
Unsure as to whether or not this works.
#+begin_src emacs-lisp :tangle yes
  (defun org-table-goto-col-beginning ()
    "Go to beginning of current column and return `point'."
    (interactive)
    ;; (assert (org-table-p) "Not in org-table.")
    (org-table-align)
    (let ((col (org-table-current-column)))
      (goto-char (org-table-begin))
      (org-table-goto-column col))
    (point))

  (defun org-table-col-beginning ()
    "Return beginning position of current column."
    (save-excursion
      (org-table-goto-col-beginning)))

  (defun org-table-goto-col-end ()
    "Goto end of current column and return `point'."
    (interactive)
    ;; (assert (org-table-p) "Not in org-table.")
    (org-table-align)
    (let ((col (org-table-current-column)))
      (goto-char (1- (org-table-end)))
      (org-table-goto-column col)
      (skip-chars-forward "^|"))
    (point))

  (defun org-table-col-end ()
    "Return end position of current column."
    (save-excursion
      (org-table-goto-col-end)))

  (defun org-table-select-col ()
    "Select current column."
    (interactive)
    (set-mark (org-table-col-beginning))
    (org-table-goto-col-end))

  (defun org-table-copy-col ()
    "Copy current column."
    (interactive)
    (save-excursion
      (org-table-copy-region (org-table-goto-col-beginning)
                             (org-table-goto-col-end))))
#+end_src

#+RESULTS:
: org-table-copy-col

** Export
Export org file to a different folder by default. Deactivated for now and using "#+EXPORT_FILE_NAME: test" in the meantime.
#+begin_src emacs-lisp :tangle no
(defun org-export-output-file-name-modified (orig-fun extension &optional subtreep pub-dir)
  (unless pub-dir
    (setq pub-dir "exported-org-files")
    (unless (file-directory-p pub-dir)
      (make-directory pub-dir)))
  (apply orig-fun extension subtreep pub-dir nil))
(advice-add 'org-export-output-file-name :around #'org-export-output-file-name-modified)
#+end_src

#+RESULTS:

#+RESULTS:
: t

*** LaTeX
#+begin_src emacs-lisp :tangle no
  ;;Latex

  (defun org/parse-headings (backend)
    (if (member backend '(latex))
        (org-map-entries
         (lambda ()
           (progn
             (insert-string "#+LATEX: \\newpage")))

         "+newpage")))


  (add-hook 'org-export-before-parsing-hook 'org/parse-headings)
#+end_src
Make use of extarticle by default
#+begin_src emacs-lisp :tangle yes
(after! org
(setq org-latex-default-class "extarticle") )
#+end_src

#+RESULTS:
: extarticle

Captions and cdlatex
#+begin_src emacs-lisp :tangle yes
  (add-hook 'org-mode #'(cdlatex-mode))


  (setq org-latex-prefer-user-labels t
        org-latex-caption-above nil
        org-latex-listings 'minted
        )


;(after! org
  ;;Colours
;(add-to-list 'org-latex-packages-alist '("" "minted"))
;(add-to-list 'org-latex-packages-alist '("" "tabularx"))
;(plist-put org-format-latex-options :scale 1.75        )
;(add-to-list 'org-latex-packages-alist '("" "unicode-math")))
  ;; Temporarily increase margins
  ;; (add-to-list 'org-latex-packages-alist '("margin=2cm" "geometry"))
#+end_src

#+RESULTS:
: time

Set XeLaTex as our compiler
#+begin_src emacs-lisp :tangle yes
(setq org-latex-compiler "xelatex")
#+end_src
 Open new windows (such as exported PDF's in a new winddow)
#+begin_src emacs-lisp :tangle yes
  (setq org-link-frame-setup '(
                               ;; (vm . vm-visit-folder-other-frame)
                               ;; (vm-imap . vm-visit-imap-folder-other-frame)
                               ;; (gnus . org-gnus-no-new-news)
                               (file . find-file-other-window) ;;modified line
                               (wl . wl-other-frame)))

;; Custom latex->PDF conversion
  ;; (setq org-latex-pdf-process
  ;;       '("latexmk -pdflatex='pdflatex -interaction nonstopmode' -shell-escape -pdf -bibtex --synctex=1 -f %f"))
  ;; (setq org-latex-pdf-process
  ;;       '("latexmk -pdflatex='lualatex -interaction nonstopmode' -shell-escape -pdf -bibtex --synctex=1 -f %f"))
  (setq latex-run-command "xelatex")
  (setq org-latex-pdf-process
        '("latexmk -pdflatex='xelatex -interaction nonstopmode ' -shell-escape -pdf -f %f "
          ;; "makeglossaries %b"
          ;; "biber %b"
          ;; "makeindex %b"
          "latexmk -pdflatex='xelatex -interaction nonstopmode ' -shell-escape -pdf -f %f "
          "latexmk -pdflatex='xelatex -interaction nonstopmode ' -shell-escape -pdf -f %f "))



#+end_src

#+RESULTS:
| latexmk -pdflatex='xelatex -interaction nonstopmode ' -shell-escape -pdf -f %f |

*** Equations
Function update-tag for sequential equation codes (Maybe not needed anymore)
#+begin_src emacs-lisp :tangle yes
  (defun update-tag ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (let ((count 1))
        (while (re-search-forward "\\tag{\\([0-9]+\\)}" nil t)
          (replace-match (format "%d" count) nil nil nil 1)
          (setq count (1+ count))))))
#+end_src

#+RESULTS:
: update-tag

*** Babel
**** Language support
#+begin_src emacs-lisp :tangle yes

(after! org-babel
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (jupyter-python . t)
     (python . t)
     (jupyter . t)
     (mermaid . t)))
 (org-babel-jupyter-override-src-block "python")
 (setq ob-async-no-async-languages-alist '("python" "jupyter"))
 (add-to-list 'org-src-lang-modes '("jupyter-python" . python))
 (add-to-list 'org-babel-tangle-lang-exts '("jupyter-python" . "py")))

       ;; (setq org-babel-default-header-args:jupyter-julia '((:async . "yes")
       ;;                                                     (:exports . "both")
       ;;                                                     (:session . "jl")
       ;;                                                     (:kernel . "julia")))

#+end_src

#+RESULTS:


***** Mermaid
#+begin_src emacs-lisp :tangle yes
 (setq ob-mermaid-cli-path (if (eq system-type 'darwin) "/opt/homebrew/bin/mmdc" "mmdc" ))

 (setq org-babel-default-header-args:mermaid
                           '(
                             (:results . "file")
                             (:width . "1080")
                             (:height . "768")
                             (:background-color . "transparent")
                             (:theme . "dark")))
#+end_src

*** Org-thesis
Classes for Thesis written in org
#+begin_src emacs-lisp :tangle yes

(use-package! ox-latex
:after org
:config
  (add-to-list 'org-latex-classes
               '("elsarticle"
                 "\\documentclass{elsarticle}
 [NO-DEFAULT-PACKAGES]
 [PACKAGES]
 [EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("mimosis"
                 "\\documentclass{mimosis}
 [NO-DEFAULT-PACKAGES]
 [PACKAGES]
 [EXTRA]
\\newcommand{\\mboxparagraph}[1]{\\paragraph{#1}\\mbox{}\\\\}
\\newcommand{\\mboxsubparagraph}[1]{\\subparagraph{#1}\\mbox{}\\\\}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\mboxparagraph{%s}" . "\\mboxparagraph*{%s}")
                 ("\\mboxsubparagraph{%s}" . "\\mboxsubparagraph*{%s}"))))
#+end_src

#+RESULTS:
: t
**** Colouring
#+begin_src emacs-lisp :tangle yes
(org-add-link-type
 "color"
 (lambda (path)
   (message (concat "color "
                    (progn (add-text-properties
                            0 (length path)
                            (list 'face `((t (:foreground ,path))))
                            path) path))))
 (lambda (path desc format)
   (cond
    ((eq format 'html)
     (format "<span style=\"color:%s;\">%s</span>" path desc))
    ((eq format 'latex)
     (format "{\\color{%s}%s}" path desc)))))

(defun correct-word-or-region()
    "Introduces yas snippet for correction, intelligently."
    (interactive)
    (let ( (snippet "corrections"))
    (cond ((region-active-p)
           (setq deactivate-mark t)
           (yas-expand-snippet (yas-lookup-snippet snippet)))
          (t (save-mark-and-excursion (set-mark (beginning-of-thing 'word)) (goto-char (end-of-thing 'word)) (yas-expand-snippet (yas-lookup-snippet snippet)))))))

(map! :localleader :map org-mode-map "w" 'correct-word-or-region)
#+end_src

#+RESULTS:


*** alphapapa
#+begin_src emacs-lisp :tangle yes
(eval-when-compile
  (require 'easy-mmode)
  (require 'ox))
(use-package ox
  :config
  (define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
    "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
    :global t
    (if unpackaged/org-export-html-with-useful-ids-mode
        (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
      (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))

  (defun unpackaged/org-export-get-reference (datum info)
    "Like `org-export-get-reference', except uses heading titles instead of random numbers."
    (let ((cache (plist-get info :internal-references)))
      (or (car (rassq datum cache))
          (let* ((crossrefs (plist-get info :crossrefs))
                 (cells (org-export-search-cells datum))
                 ;; Preserve any pre-existing association between
                 ;; a search cell and a reference, i.e., when some
                 ;; previously published document referenced a location
                 ;; within current file (see
                 ;; `org-publish-resolve-external-link').
                 ;;
                 ;; However, there is no guarantee that search cells are
                 ;; unique, e.g., there might be duplicate custom ID or
                 ;; two headings with the same title in the file.
                 ;;
                 ;; As a consequence, before re-using any reference to
                 ;; an element or object, we check that it doesn't refer
                 ;; to a previous element or object.
                 (new (or (cl-some
                           (lambda (cell)
                             (let ((stored (cdr (assoc cell crossrefs))))
                               (when stored
                                 (let ((old (org-export-format-reference stored)))
                                   (and (not (assoc old cache)) stored)))))
                           cells)
                          (when (org-element-property :raw-value datum)
                            ;; Heading with a title
                            (unpackaged/org-export-new-title-reference datum cache))
                          ;; NOTE: This probably breaks some Org Export
                          ;; feature, but if it does what I need, fine.
                          (org-export-format-reference
                           (org-export-new-reference cache))))
                 (reference-string new))
            ;; Cache contains both data already associated to
            ;; a reference and in-use internal references, so as to make
            ;; unique references.
            (dolist (cell cells) (push (cons cell new) cache))
            ;; Retain a direct association between reference string and
            ;; DATUM since (1) not every object or element can be given
            ;; a search cell (2) it permits quick lookup.
            (push (cons reference-string datum) cache)
            (plist-put info :internal-references cache)
            reference-string))))

  (defun unpackaged/org-export-new-title-reference (datum cache)
    "Return new reference for DATUM that is unique in CACHE."
    (cl-macrolet ((inc-suffixf (place)
                               `(progn
                                  (string-match (rx bos
                                                    (minimal-match (group (1+ anything)))
                                                    (optional "--" (group (1+ digit)))
                                                    eos)
                                                ,place)
                                  ;; HACK: `s1' instead of a gensym.
                                  (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                             (match-string 2 ,place)))
                                          (suffix (if suffix
                                                      (string-to-number suffix)
                                                    0)))
                                    (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
      (let* ((title (org-element-property :raw-value datum))
             (ref (url-hexify-string (substring-no-properties title)))
             (parent (org-element-property :parent datum)))
        (while (--any (equal ref (car it))
                      cache)
          ;; Title not unique: make it so.
          (if parent
              ;; Append ancestor title.
              (setf title (concat (org-element-property :raw-value parent)
                                  "--" title)
                    ref (url-hexify-string (substring-no-properties title))
                    parent (org-element-property :parent parent))
            ;; No more ancestors: add and increment a number.
            (inc-suffixf ref)))
        ref))))
#+end_src

Add the org reference everywhere
**** TODO make it conditional to html export, or replace %20 with "--", as it breaks pdf export
#+begin_src emacs-lisp :tangle no
;; (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
;; (advice-add #'org-export-get-reference :override #'org-export-get-reference)
#+end_src
#+RESULTS:

** Org-ref
Last used for PhD thesis acronyms
*** Glossary
Add shortcuts to add referentiable acronyms and glossary
 #+begin_src emacs-lisp :tangle no

(after! org
 (map! :localleader :map org-mode-map
       "l a" #'org-ref-insert-acronym-link
       "l g" #'org-ref-insert-glossary-link)
 )

#+end_src

#+RESULTS:


Maybe expand glossary formatting in the future
#+begin_src emacs-lisp :tangle yes
;; (setf org-ref-glossary-gls-commands
;;       (append  org-ref-glossary-gls-commands
;;                '( ("glslbl"  "The associated label (generally the accronym)"))))

#+end_src

*** Export
#+begin_src emacs-lisp :tangle no
(setq org-export-before-parsing-functions '(org-ref-glossary-before-parsing org-ref-acronyms-before-parsing))
#+end_src

#+RESULTS:
| org-ref-glossary-before-parsing | org-ref-acronyms-before-parsing |
** Org-latex integration

#+begin_src emacs-lisp :tangle yes
(add-to-list 'org-preview-latex-process-alist '(dvisvgm :programs
                                                  ("latex" "dvisvgm")
                                                  :description "dvi > svg" :message "you need to install the programs: latex and dvisvgm." :use-xcolor t :image-input-type "xdv" :image-output-type "svg" :image-size-adjust
                                                  (1.7 . 1.5)
                                                  :latex-compiler
                                                  ("latexmk -xelatex -interaction=nonstopmode -shell-escape -output-directory=%o %f")
                                                  :image-converter
                                                  ("dvisvgm %f -n -b min -c %S -o %O")))
(setq org-preview-latex-default-process 'dvisvgm)

  ;; png requires a newer version of dvipng (1.17) to work with xelatex
  ;; (add-to-list 'org-preview-latex-process-alist '(dvipng :programs
  ;;                                                        ("latex" "dvipng")
  ;;                                                        :description "dvi > png" :message "you need to install the programs: latex and dvipng." :image-input-type "xdv" :image-output-type "png" :image-size-adjust
  ;;                                                        (1.0 . 1.0)
  ;;                                                        :latex-compiler
  ;;                                                        ;; ("latexmk -pdflatex='xelatex -interaction nonstopmode -output-directory %o' -shell-escape  %f")
  ;;                                                        ("latexmk -xelatex -interaction=nonstopmode -shell-escape -output-directory=%o %f")
  ;;                                                        ;; ("latexmk -pdflatex='xelatex -interaction nonstopmode' -shell-escape -pdf -f %f")
  ;;                                                        :image-converter
  ;;                                                        ("dvipng -D %D -T tight -o %O %f")
  ;;                                                        :transparent-image-converter
  ;;                                                        ("dvipng -D %D -T tight -bg Transparent -o %O %f")))

  ;; (setq org-latex-inputenc-alist '(("utf8" . "utf8x")))
                                        ;)
#+end_src

#+RESULTS:
: dvisvgm

** Latex

#+begin_src emacs-lisp :tangle yes
;;; Latex settings
(after! latex
  (setq TeX-view-program-selection '((output-pdf "Okular")))

  (setq org-export-with-smart-quotes t)
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-start-server t)
  (setq TeX-source-correlate-method 'synctex)
  (setq TeX-view-program-list
        '(("Okular" "okular --unique %o#src:%n`pwd`/./%b")
          ("Skim" "displayline -b -g %n %o %b")
          ("Zathura"
           ("zathura %o"
            (mode-io-correlate
             " --synctex-forward %n:0:%b -x \"emacsclient +%{line} %{input}\"")))))
  (setq org-latex-image-default-width "\\linewidth")
  )
#+end_src

#+RESULTS:

*** Unused
TODO: Check how to make this work in org-mode
**** Tex Mode
#+begin_src emacs-lisp :tangle no
(defun slot/LaTeX-self-insert (&optional arg char)
  "`self-insert-command' for LaTeX mode.
If the previous word is just a single character, surround it with
dollar signs.  If already in math mode, do nothing.  If the
character is a single `a', do nothing.

If called with a single \\[universal-argument], just call
`self-insert-command'.
Obtained from https://tony-zorman.com/posts/2022-10-22-emacs-potpourri.html"
  (interactive "P")
  (pcase arg
    ('(4) (self-insert-command 1))
    (_ (let ((ppoint (save-excursion (backward-word)       (point)))
             (ipoint (save-excursion (back-to-indentation) (point)))
             (word   (word-at-point)))
         (unless (or (length> word 1)   ; longer than a single character
                     (not word)
                     (= ipoint ppoint)  ; the first thing on a new line
                     (equal "a" word)
                     (number-at-point)
                     (texmathp))
           (-let (((open . close) math-delimiters-inline))
             (backward-char)
             (insert open)
             (forward-char 1)
             (insert close)))
         (self-insert-command 1 char)))))

;; (defvar org-babel-julia-write-object-command "writecsv(\"%s\",%s)")
#+end_src

#+RESULTS:
: slot/LaTeX-self-insert

** Org-poster
#+begin_src emacs-lisp :tangle yes
(after! org
 (add-to-list 'org-latex-classes
         '("beamerposter"
           "\\documentclass[final]{beamer}
           \\usepackage[T1]{fontenc}
           \\usepackage{lmodern}
           \\usepackage[size=custom,width=120,height=91,scale=1.0]{beamerposter}
           \\usepackage{graphicx}
           \\usepackage{booktabs}
           \\usepackage{tikz}
           \\usepackage{pgfplots}
           \\pgfplotsset{compat=1.14}
           \\usepackage{anyfontsize}
           [NO-DEFAULT-PACKAGES]"))
 (add-to-list 'org-latex-classes
         '("extarticle"
                 "\\documentclass{extarticle}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))

#+end_src

#+RESULTS:
| extarticle   | \documentclass{extarticle}    | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |                                            |
| extarticle   | \documentclass{extarticle}    | (\chapter{%s} . \chapter*{%s}) | (\section{%s} . \section*{%s})       | (\subsection{%s} . \subsection*{%s})       | (\subsubsection{%s} . \subsubsection*{%s}) |
| beamerposter | \documentclass[final]{beamer} |                                |                                      |                                            |                                            |

** Capture
#+begin_src emacs-lisp :tangle yes
;; (setq org-chef-folder (substitute-in-filename "$HOME/Documents/sync/org/personal/recipes/recipes/"))
(defun transform-square-brackets-to-round-ones(string-to-transform)
  "Transforms [ into ( and ] into ), other chars left unchanged."
  (concat
  (mapcar #'(lambda (c) (if (equal c ?\[) ?\( (if (equal c ?\]) ?\) c))) string-to-transform))
  )

(setq org-capture-templates
      '(
	("p" "Protocol" entry (file+headline "notes.org" "Inbox")
        "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?")
	("L" "Protocol Link" entry (file+headline "notes.org" "Inbox")
        "* %? [[%:link][%(transform-square-brackets-to-round-ones \"%:description\")]]\n")
        ("c" "Cookbook" entry (file "personal/recipes/recipes/cookbook.org")
         "%(org-chef-get-recipe-from-url)"
         :empty-lines 1)
        ("m" "Manual Cookbook" entry (file "personal/recipes/cookbook.org")
         "* %^{Recipe title: }\n  :PROPERTIES:\n  :source-url:\n  :servings:\n  :prep-time:\n  :cook-time:\n  :ready-in:\n  :END:\n** Ingredients\n   %?\n** Directions\n\n")
))
#+end_src

#+RESULTS:
| c | Cookbook        | entry | (file ~/Documents/sync/org/personal/recipes/recipes/cookbook.org) | %(org-chef-get-recipe-from-url) | :empty-lines | 1 |
| m | Manual Cookbook | entry | (file ~/org/cookbook.org)                                         | * %^{Recipe title: }            |              |   |




Capture template
#+begin_src emacs-lisp :tangle yes
(defun capture-report-date-file (path)
  (let ((name (read-string "Name: ")))
    (expand-file-name (format "%s-%s.txt"
                              (format-time-string "%Y-%m-%d")
                              name) path)))

'(("t"
   "todo"
   entry
   (file (capture-report-date-file  "~/path/path/name"))
   "* TODO"))
#+end_src
** Customisations
Open pdfs inside emacs instead of other window
#+begin_src emacs-lisp :tangle yes
(add-to-list 'org-file-apps '("\\.pdf\\'" . emacs))
(add-to-list 'org-file-apps '("\\.eml\\'" . emacs))
#+end_src

#+RESULTS:
: ((\.pdf\' . emacs) (remote . emacs) (auto-mode . emacs) (directory . emacs) (\.mm\' . default) (\.x?html?\' . default) (\.pdf\' . default))

* Markdown
#+begin_src emacs-lisp :tangle yes
(setq markdown-max-image-size (cons (/ 1920 2) (/ 1080 2)))
#+end_src

Display  markdown in html, use alongside impatient-mode
#+begin_src emacs-lisp :tangle yes
(defun markdown-html (buffer)
    (princ (with-current-buffer buffer
            (format "<!DOCTYPE html><html><title>Impatient Markdown</title><xmp theme=\"united\" style=\"display:none;\"> %s  </xmp><script src=\"http://ndossougbe.github.io/strapdown/dist/strapdown.js\"></script></html>" (buffer-substring-no-properties (point-min) (point-max))))
     (current-buffer)))

#+end_src

Interactive functions to activate and deactivate serving markdown as html
#+begin_src emacs-lisp :tangle yes
(defun serve-buffer-as-html ()
  (interactive)
  (httpd-start)
  (unless (bound-and-true-p impatient-mode) (impatient-mode))
  (imp-set-user-filter 'markdown-html))

(defun stop-impatient-service ()
  (interactive)
  (when (bound-and-true-p impatient-mode) (impatient-mode))
  (httpd-stop))

#+end_src

#+RESULTS:
: stop-impatient-service

* Spell
#+begin_src emacs-lisp :tangle yes
(setq synosaurus-choose-method 'popup)
(setq org-M-RET-may-split-line t)
(setf org-blank-before-new-entry '((heading . auto) (plain-list-item . nil)))
#+end_src

#+RESULTS:
: ((heading . auto) (plain-list-item))
#+end_src

* Magit

Track =mv= with git
#+begin_src elisp :tangle yes
(setq dired-vc-rename-file t)
#+end_src

Commit message templates
#+begin_src emacs-lisp :tangle yes
(after! magit
  (defun +list-commit-predicates ()
    (interactive)
    "
~change~: Change the implementation of an existing feature
~feat~: Add new feature.
~fix~: Fixes a bug.
~remove~: Removes a feature.
~perf~: Improves performance of an algorithm or execution time.
~refactor~: Neither fixes bug nor adds/change feature, restructuring.
~build~: Change the build system or external dependencies, i.e. adding, removing, upgrading dependencies.
~chore~: Maintenance task or boilerplate code.  This is not tied to a specific feature.
~ci~: Change continuous integration configuration files and scripts
~test~: Add or correct tests
~docs~: Changes that only affect documentation.
      + Example: Edited the docstring for the ~foobar()~ function so that it is clear that it takes a ~pandas.DataFrame~ as an input.
~style~: Does not affect meaning of code -- e.g. white-space, formatting, etc.
      + Example: Rearranged import statements alphabetically using ~isort~.

Full list at https://www.wiki.ed.ac.uk/pages/viewpage.action?spaceKey=SWAIN&title=Git+commit+template
"

    (list "change" "feat" "fix" "remove" "perf" "refactor" "build" "chore" "ci" "test" "docs" "style"))



  (defun +current-repo-scopes ()
    "
helper function to provide scopes

todo make automatic toplevel detection and list folders/subfolders at toplevel
"

    (require 'cl-lib)

    (let*
        ((repo-name (car (last (split-string (vc-root-dir) "/") 2)))
         (repo-scopes (cl-pairlis '("aliby") '(("agora" "aliby" "ext" "logp" "post" "meta" "pipe"))))
         (current-repo-scopes (cdr (assoc repo-name repo-scopes))))

      (if (bound-and-true-p current-repo-scopes)
          current-repo-scopes (message "repo not in list")))))
#+end_src

Copy file and line number to kill-ring
#+begin_src emacs-lisp :tangle yes
(after! browse-at-remote
 (setq browse-at-remote-remote-type-regexps (push '(:host "^git\\.ecdf\\.ed\\.ac\\.uk$" :type "gitlab")  browse-at-remote-remote-type-regexps)))
#+end_src

#+RESULTS:

Difftastic integration
#+begin_src emacs-lisp :tangle yes
(after! magit
(defun th/magit--with-difftastic (buffer command)
  "Run COMMAND with GIT_EXTERNAL_DIFF=difft then show result in BUFFER."
  (let ((process-environment
         (cons (concat "GIT_EXTERNAL_DIFF=difft --width="
                       (number-to-string (frame-width)))
               process-environment)))
    ;; Clear the result buffer (we might regenerate a diff, e.g., for
    ;; the current changes in our working directory).
    (with-current-buffer buffer
      (setq buffer-read-only nil)
      (erase-buffer))
    ;; Now spawn a process calling the git COMMAND.
    (make-process
     :name (buffer-name buffer)
     :buffer buffer
     :command command
     ;; Don't query for running processes when emacs is quit.
     :noquery t
     ;; Show the result buffer once the process has finished.
     :sentinel (lambda (proc event)
                 (when (eq (process-status proc) 'exit)
                   (with-current-buffer (process-buffer proc)
                     (goto-char (point-min))
                     (ansi-color-apply-on-region (point-min) (point-max))
                     (setq buffer-read-only t)
                     (view-mode)
                     (end-of-line)
                     ;; difftastic diffs are usually 2-column side-by-side,
                     ;; so ensure our window is wide enough.
                     (let ((width (current-column)))
                       (while (zerop (forward-line 1))
                         (end-of-line)
                         (setq width (max (current-column) width)))
                       ;; Add column size of fringes
                       (setq width (+ width
                                      (fringe-columns 'left)
                                      (fringe-columns 'right)))
                       (goto-char (point-min))
                       (pop-to-buffer
                        (current-buffer)
                        `(;; If the buffer is that wide that splitting the frame in
                          ;; two side-by-side windows would result in less than
                          ;; 80 columns left, ensure it's shown at the bottom.
                          ,(when (> 80 (- (frame-width) width))
                             #'display-buffer-at-bottom)
                          (window-width
                           . ,(min width (frame-width))))))))))))
(defun th/magit-show-with-difftastic (rev)
  "Show the result of \"git show REV\" with GIT_EXTERNAL_DIFF=difft."
  (interactive
   (list (or
          ;; If REV is given, just use it.
          (when (boundp 'rev) rev)
          ;; If not invoked with prefix arg, try to guess the REV from
          ;; point's position.
          (and (not current-prefix-arg)
               (or (magit-thing-at-point 'git-revision t)
                   (magit-branch-or-commit-at-point)))
          ;; Otherwise, query the user.
          (magit-read-branch-or-commit "Revision"))))
  (if (not rev)
      (error "No revision specified")
    (th/magit--with-difftastic
     (get-buffer-create (concat "*git show difftastic " rev "*"))
     (list "git" "--no-pager" "show" "--ext-diff" rev))))

(defun th/magit-diff-with-difftastic (arg)
  "Show the result of \"git diff ARG\" with GIT_EXTERNAL_DIFF=difft."
  (interactive
   (list (or
          ;; If RANGE is given, just use it.
          (when (boundp 'range) range)
          ;; If prefix arg is given, query the user.
          (and current-prefix-arg
               (magit-diff-read-range-or-commit "Range"))
          ;; Otherwise, auto-guess based on position of point, e.g., based on
          ;; if we are in the Staged or Unstaged section.
          (pcase (magit-diff--dwim)
            ('unmerged (error "unmerged is not yet implemented"))
            ('unstaged nil)
            ('staged "--cached")
            (`(stash . ,value) (error "stash is not yet implemented"))
            (`(commit . ,value) (format "%s^..%s" value value))
            ((and range (pred stringp)) range)
            (_ (magit-diff-read-range-or-commit "Range/Commit"))))))
  (let ((name (concat "*git diff difftastic"
                      (if arg (concat " " arg) "")
                      "*")))
    (th/magit--with-difftastic
     (get-buffer-create name)
     `("git" "--no-pager" "diff" "--ext-diff" ,@(when arg (list arg))))))

(transient-define-prefix th/magit-aux-commands ()
  "My personal auxiliary magit commands."
  ["Auxiliary commands"
   ("d" "Difftastic Diff (dwim)" th/magit-diff-with-difftastic)
   ("s" "Difftastic Show" th/magit-show-with-difftastic)])

(define-key magit-status-mode-map (kbd "#") #'th/magit-aux-commands)
)
#+end_src

Add conventional commit completion
#+begin_src emacs-lisp :tangle yes
(use-package conventional-commit
  :hook
  (git-commit-mode . conventional-commit-setup))

(add-hook 'company-backends #'company-capf)
#+end_src

Forge copy issue url
#+begin_src emacs-lisp :tangle yes
(map! :map magit-mode-map :gnv "SPC g p" 'forge-copy-url-at-point-as-kill)
#+end_src

#+RESULTS:

* PDF-tools
#+begin_src emacs-lisp :tangle yes
;; TODO check if hooks are working
(add-hook 'doc-view-mode #'pdf-view-mode)
(add-hook 'pdf-view-mode #'pdf-view-midnight-minor-mode)
(add-hook 'pdf-view-mode #'pdf-view-roll-minor-mode)
(setq pdf-view-resize-factor 1.05)
#+end_src

* Discovery

#+begin_src emacs-lisp :tangle yes
(setq use-package-enable-imenu-support t)
#+end_src

#+RESULTS:
: t

* Tramp
#+begin_src emacs-lisp :tangle yes
(after! tramp
  (setq auto-revert-remote-files t))
#+end_src

#+RESULTS:
: t

Use zsh remotely if possible
#+begin_src emacs-lisp :tangle no
 (after! tramp
 (add-to-list 'tramp-connection-properties
              (list (regexp-quote "/ssh:user@host:")
                    "remote-shell" "/usr/bin/zsh"))
 (customize-set-variable 'tramp-encoding-shell "/usr/bin/zsh")
 )

#+end_src

#+RESULTS:
: /usr/bin/zsh

* Snippets
yas-snippets everywhere
#+begin_src emacs-lisp :tangle yes
(yas-global-mode 1)
#+end_src

#+RESULTS:
: t
* Credentials

#+begin_src emacs-lisp :tangle yes
(setq auth-sources '("~/.authinfo"))
#+end_src

** GPT
#+begin_src emacs-lisp :tangle yes
(setq openai-key "REMOVED")
#+end_src

** AWS
*** AXE
#+begin_src emacs-lisp :tangle no
; Set this value if aws credentials are not in ~/.aws/credentials
(setq aws-credential-file nil)
#+end_src
*** S3ED
#+begin_src emacs-lisp :tangle no
(require 's3ed)
#+end_src

*** Rsync
#+begin_src emacs-lisp :tangle yes
(setq dired-rsync-options "-az --progress")
#+end_src

